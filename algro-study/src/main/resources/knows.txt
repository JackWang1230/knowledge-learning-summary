




如果 p 的第 j 个字符是 *，那么就表示我们可以对 p 的第 j-1个字符匹配任意自然数次。在匹配 0 次的情况下，我们有

f[i][j] = f[i][j - 2]
也就是我们「浪费」了一个字符 + 星号的组合，没有匹配任何 s 中的字符。
我们用 f[i][j] 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配

f[i][j] 表示 s[i] 和 p[j] 个值是否boolean



f[i][j] 表示s的都i个值 p的第j个值
1) 单纯字符串类型的时候
                 f[i][j]=f[i-1][j-1] => 即一一对应
2) 第二种涉及*的时候 （*表示 可以匹配前一个字符的 零次或者n次）
                1) 如果匹配了0次 要等式返回 true，则
                 f[i][j] = f[i][j-2]


// 二叉树
前序遍历: 先访问根节点 再访问左子树、右子树


// 贪心算法总结
1. 首先找出所有数值去重后的数据List1
2. 依次基于每一份数据 与当前数据进行比较 后记录List1还剩的数据量
3. 若数据剩余量记录数不为0，则跳过

// KMP算法
1. 模式串在文本串中是否出现过
2. 常用与在一个文本字符串 s 内查找一个模式串 P 的出现位置






